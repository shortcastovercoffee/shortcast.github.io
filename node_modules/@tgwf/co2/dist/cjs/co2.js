"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var co2_exports = {};
__export(co2_exports, {
  CO2: () => CO2,
  default: () => co2_default
});
module.exports = __toCommonJS(co2_exports);
var import_byte = __toESM(require("./1byte.js"));
var import_sustainable_web_design = __toESM(require("./sustainable-web-design.js"));
var import_constants = require("./constants/index.js");
var import_helpers = require("./helpers/index.js");
class CO2 {
  constructor(options) {
    this.model = new import_sustainable_web_design.default();
    if ((options == null ? void 0 : options.model) === "1byte") {
      this.model = new import_byte.default();
    } else if ((options == null ? void 0 : options.model) === "swd") {
      this.model = new import_sustainable_web_design.default();
    } else if (options == null ? void 0 : options.model) {
      throw new Error(`"${options.model}" is not a valid model. Please use "1byte" for the OneByte model, and "swd" for the Sustainable Web Design model.
See https://developers.thegreenwebfoundation.org/co2js/models/ to learn more about the models available in CO2.js.`);
    }
    this._segment = (options == null ? void 0 : options.results) === "segment";
  }
  perByte(bytes, green = false) {
    return this.model.perByte(bytes, green, this._segment);
  }
  perVisit(bytes, green = false) {
    var _a;
    if ((_a = this.model) == null ? void 0 : _a.perVisit) {
      return this.model.perVisit(bytes, green, this._segment);
    } else {
      throw new Error(`The perVisit() method is not supported in the model you are using. Try using perByte() instead.
See https://developers.thegreenwebfoundation.org/co2js/methods/ to learn more about the methods available in CO2.js.`);
    }
  }
  perByteTrace(bytes, green = false, options = {}) {
    var _a, _b, _c, _d, _e, _f;
    let adjustments = {};
    if (options) {
      adjustments = (0, import_helpers.parseOptions)(options);
    }
    return {
      co2: this.model.perByte(bytes, green, this._segment, adjustments),
      green,
      variables: {
        description: "Below are the variables used to calculate this CO2 estimate.",
        bytes,
        gridIntensity: {
          description: "The grid intensity (grams per kilowatt-hour) used to calculate this CO2 estimate.",
          network: ((_b = (_a = adjustments == null ? void 0 : adjustments.gridIntensity) == null ? void 0 : _a.network) == null ? void 0 : _b.value) ?? import_constants.GLOBAL_GRID_INTENSITY,
          dataCenter: green ? import_constants.RENEWABLES_GRID_INTENSITY : ((_d = (_c = adjustments == null ? void 0 : adjustments.gridIntensity) == null ? void 0 : _c.dataCenter) == null ? void 0 : _d.value) ?? import_constants.GLOBAL_GRID_INTENSITY,
          production: import_constants.GLOBAL_GRID_INTENSITY,
          device: ((_f = (_e = adjustments == null ? void 0 : adjustments.gridIntensity) == null ? void 0 : _e.device) == null ? void 0 : _f.value) ?? import_constants.GLOBAL_GRID_INTENSITY
        }
      }
    };
  }
  perVisitTrace(bytes, green = false, options = {}) {
    var _a, _b, _c, _d, _e, _f, _g;
    if ((_a = this.model) == null ? void 0 : _a.perVisit) {
      let adjustments = {};
      if (options) {
        adjustments = (0, import_helpers.parseOptions)(options);
      }
      return {
        co2: this.model.perVisit(bytes, green, this._segment, adjustments),
        green,
        variables: {
          description: "Below are the variables used to calculate this CO2 estimate.",
          bytes,
          gridIntensity: {
            description: "The grid intensity (grams per kilowatt-hour) used to calculate this CO2 estimate.",
            network: ((_c = (_b = adjustments == null ? void 0 : adjustments.gridIntensity) == null ? void 0 : _b.network) == null ? void 0 : _c.value) ?? import_constants.GLOBAL_GRID_INTENSITY,
            dataCenter: green ? import_constants.RENEWABLES_GRID_INTENSITY : ((_e = (_d = adjustments == null ? void 0 : adjustments.gridIntensity) == null ? void 0 : _d.dataCenter) == null ? void 0 : _e.value) ?? import_constants.GLOBAL_GRID_INTENSITY,
            production: import_constants.GLOBAL_GRID_INTENSITY,
            device: ((_g = (_f = adjustments == null ? void 0 : adjustments.gridIntensity) == null ? void 0 : _f.device) == null ? void 0 : _g.value) ?? import_constants.GLOBAL_GRID_INTENSITY
          },
          dataReloadRatio: (adjustments == null ? void 0 : adjustments.dataReloadRatio) ?? 0.02,
          firstVisitPercentage: (adjustments == null ? void 0 : adjustments.firstVisitPercentage) ?? 0.75,
          returnVisitPercentage: (adjustments == null ? void 0 : adjustments.returnVisitPercentage) ?? 0.25
        }
      };
    } else {
      throw new Error(`The perVisitDetailed() method is not supported in the model you are using. Try using perByte() instead.
See https://developers.thegreenwebfoundation.org/co2js/methods/ to learn more about the methods available in CO2.js.`);
    }
  }
  perDomain(pageXray, greenDomains) {
    const co2PerDomain = [];
    for (let domain of Object.keys(pageXray.domains)) {
      let co2;
      if (greenDomains && greenDomains.indexOf(domain) > -1) {
        co2 = this.perByte(pageXray.domains[domain].transferSize, true);
      } else {
        co2 = this.perByte(pageXray.domains[domain].transferSize);
      }
      co2PerDomain.push({
        domain,
        co2,
        transferSize: pageXray.domains[domain].transferSize
      });
    }
    co2PerDomain.sort((a, b) => b.co2 - a.co2);
    return co2PerDomain;
  }
  perPage(pageXray, green) {
    const domainCO2 = this.perDomain(pageXray, green);
    let totalCO2 = 0;
    for (let domain of domainCO2) {
      totalCO2 += domain.co2;
    }
    return totalCO2;
  }
  perContentType(pageXray, greenDomains) {
    const co2PerContentType = {};
    for (let asset of pageXray.assets) {
      const domain = new URL(asset.url).domain;
      const transferSize = asset.transferSize;
      const co2ForTransfer = this.perByte(transferSize, greenDomains && greenDomains.indexOf(domain) > -1);
      const contentType = asset.type;
      if (!co2PerContentType[contentType]) {
        co2PerContentType[contentType] = { co2: 0, transferSize: 0 };
      }
      co2PerContentType[contentType].co2 += co2ForTransfer;
      co2PerContentType[contentType].transferSize += transferSize;
    }
    const all = [];
    for (let type of Object.keys(co2PerContentType)) {
      all.push({
        type,
        co2: co2PerContentType[type].co2,
        transferSize: co2PerContentType[type].transferSize
      });
    }
    all.sort((a, b) => b.co2 - a.co2);
    return all;
  }
  dirtiestResources(pageXray, greenDomains) {
    const allAssets = [];
    for (let asset of pageXray.assets) {
      const domain = new URL(asset.url).domain;
      const transferSize = asset.transferSize;
      const co2ForTransfer = this.perByte(transferSize, greenDomains && greenDomains.indexOf(domain) > -1);
      allAssets.push({ url: asset.url, co2: co2ForTransfer, transferSize });
    }
    allAssets.sort((a, b) => b.co2 - a.co2);
    return allAssets.slice(0, allAssets.length > 10 ? 10 : allAssets.length);
  }
  perParty(pageXray, greenDomains) {
    let firstParty = 0;
    let thirdParty = 0;
    const firstPartyRegEx = pageXray.firstPartyRegEx;
    for (let d of Object.keys(pageXray.domains)) {
      if (!d.match(firstPartyRegEx)) {
        thirdParty += this.perByte(pageXray.domains[d].transferSize, greenDomains && greenDomains.indexOf(d) > -1);
      } else {
        firstParty += this.perByte(pageXray.domains[d].transferSize, greenDomains && greenDomains.indexOf(d) > -1);
      }
    }
    return { firstParty, thirdParty };
  }
}
var co2_default = CO2;
//# sourceMappingURL=co2.js.map
